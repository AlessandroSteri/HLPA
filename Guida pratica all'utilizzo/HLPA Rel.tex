\documentclass[]{article}
\usepackage{amsmath,verbatimbox}
\usepackage{fancyvrb}

\title{Hoare Logic Proof Assistant}
\author{Chiara Fanco, Emilian Postolache, Andrea Proietto, Alessandro Steri}

\begin{document}

\maketitle

\begin{abstract}
Il progetto prevede lo sviluppo in ML di un \emph{proof assistant} interattivo per la logica di Hoare.
\par
Lo scopo del documento \`e descrivere e motivare le scelte progettuali adottate, oltrech\'e fornire le istruzioni per l'uso dell'applicazione.
\end{abstract}

\section{Overview dell'applicazione}
L'applicazione supporta l'utente nel provare la correttezza parziale di un programma imperativo scritto nel linguaggio \emph{Imp}. A tal fine prende in input una formula $F$ della logica di Hoare che rappresenta la specifica del programma e ne dimostra la verit\`a costruendo l'albero di derivazione mediante le regole di inferenza, denominate "tactic" in quanto segue, specificate dall'utente.
\par
In ogni momento, l'applicazione mantiene in memoria lo stato corrente della dimostrazione. Esso consiste di una lista di formule che rappresentano le foglie dell'albero di derivazione costruito fino a quel momento.
\par
Lo stato iniziale $S_0$ della dimostrazione contiene la sola formula $F$. Partendo da un generico stato $S_t$, l'utente genera lo stato successivo $S_{t+1}$ applicando una tactic $T$ ad una formula $F'$ di $S_t$. Il nuovo stato $S_{t+1}$ \`e dunque ottenuto sostituendo $F'$ in $S_t$ con le premesse derivate.
\par
Se una formula \`e un assioma, viene rimossa dallo stato; ne consegue che $F$ \`e dimostrata quando si raggiunge uno stato vuoto.
\par
Alcune tactic, laddove non siano in grado di determinare la precondizione o la postcondizione di una formula, introducono delle "meta-variabili", convenzionalmente indicate con $\_a$, che fungono da segnaposto per un'espressione booleana.
\par
Nel prosieguo della dimostrazione, potrebbe accadere che, applicando una nuova tactic ad una formula $F'$ con una meta-variabile $\_a$, si riesca a calcolarne la corrispondente espressione booleana $exp$. In tal caso, $\_a$ viene rimpiazzata in $F'$ con un "meta-valore", convenzionalmente indicato con $\_a : exp$, che associa $exp$ ad $\_a$.
\par
A questo punto \`e possibile sostituire con $exp$ le meta-variabili ed i meta-valori di nome $\_a$ presenti nelle formule dello stato corrente. Tale processo prende il nome di "normalizzazione".
\par
Si osservi che, calcolata l'espressione booleana per una determinata meta-variabile, si sarebbe potuta eseguire direttamente la normalizzazione senza ricorrere all'uso dei meta-valori. Tuttavia, sviluppando rami diversi dell'albero di derivazione, si potrebbero ottenere per una stessa meta-variabile espressioni booleane differenti. In tal caso, i meta-valori consentono all'utente di scegliere l'espressione che gli sembra pi\`u idonea per la normalizzazione.

\section{Struttura dell'applicazione}
L'applicazione consiste di 6 moduli:
\begin{itemize}
	\item \textbf{Hoare}: definisce la sintassi astratta del linguaggio Imp e delle formule di Hoare; include, inoltre, delle funzioni di utility per manipolare le formule.
    \item \textbf{Lexer}: implementa un analizzatore lessicale che prende in input una stringa, la esamina e la suddivide in token.
    \item \textbf{Parser}: analizza i token prodotti dal Lexer e li traduce in una formula di Hoare applicando gli operatori della sintassi astratta.
    \item \textbf{Printer}: converte le formule in stringhe e le stampa sullo standard output.
    \item \textbf{Rule}: include le funzioni che implementano le tactic e quelle che manipolano lo stato. 
    \item \textbf{Controller}: espone i comandi mediante i quali l'utente interagisce con l'applicazione.
\end{itemize}

\section{Sintassi astratta}
La sintassi astratta \`e rappresentata sotto forma dei seguenti datatype:
 
\begin{center}
\begin{BVerbatim}
datatype numExp = Num  of int
                | Var  of string
                | Plus of numExp * numExp

datatype boolExp = Bool    of bool
                 | Not     of boolExp
                 | Meta    of string
                 | MetaVal of string * boolExp
                 | And     of boolExp * boolExp
                 | Or      of boolExp * boolExp
                 | Impl    of boolExp * boolExp
                 | Minor   of numExp * numExp
                 | Equal   of numExp * numExp

datatype prog = Skip
              | Comp   of prog * prog
              | Assign of string * numExp
              | While  of boolExp * prog
              | If     of boolExp * prog * prog

datatype form = Prop   of boolExp
              | Triple of boolExp * prog * boolExp
\end{BVerbatim}
\end{center}

Va notato che, rispetto alla sintassi astratta riportata nella sezione 10.2 delle Note, sono stati aggiunti per le espressioni booleane i costruttori Meta e MetaVal, usati per definire, rispettivamente, le meta-variabili ed i meta-valori. 

\section{Tactic}
La signature RULE definisce i tipi \emph{state} e \emph{tactic} usati per rappresentare, rispettivamente, lo stato di una dimostrazione e le tactic. In particolare, \emph{state} \`e dichiarato come un tipo astratto, mentre \emph{tactic} come una funzione $state \rightarrow state$.
\par
Nella structure Rule \emph{state} \`e rappresentato come un datatype con un costruttore \emph{State} che prende in input una lista di formule ed un intero usato per generare i nomi delle meta-variabili.
\par
Come gi\`a accennato, il modulo Rule contiene, tra le altre, le funzioni che implementano le tactic. Esse, ad eccezione di tacMeta di cui si parler\`a in seguito, hanno tipo $int \rightarrow tactic$, ovvero prendono come argomenti l'indice di una formula e lo stato corrente e restituiscono un nuovo stato.
\par
Le tactic possono essere suddivise in due classi:
\begin{itemize}
	\item base-tactic
	\begin{enumerate}
		\item tacAxiom
		\item tacSkip 
		\item tacAssign
		\item tacWhile
		\item tacIf
		\newcounter{enumTemp}
		\setcounter{enumTemp}{\theenumi}
	\end{enumerate}
	\item meta-tactic
	\begin{enumerate}
		\setcounter{enumi}{\theenumTemp}
		\item tacStr
		\item tacWeak 
		\item tacComp
		\setcounter{enumTemp}{\theenumi}
	\end{enumerate}
\end{itemize}
\par
Le base-tactic, a differenza delle meta-tactic, non introducono meta-variabili. La (1) verifica che la formula su cui \`e invocata sia effettivamente un assioma e, in tal caso, la elimina dallo stato. La (2), quando applicata ad una formula contenente una meta-variabile per la precondizione o per la postcondizione del programma \emph{skip}, calcola l'espressione booleana corrispondente in accordo con la regola (\emph{skip}). Analogamente per la (3). Tutte le altre tactic sono semplicemente un'implementazione delle relative regole di inferenza.
\par
Non rientrano nella suddetta classificazione due tactic usate per la normalizzazione:
\begin{enumerate}
	\setcounter{enumi}{\theenumTemp}
	\item tacNorm
	\item tacMeta 
\end{enumerate}
\par
La (9) ottiene il primo meta-valore presente in una formula, se esiste, e lo utilizza per effettuare la normalizzazione.
\par
La (10) consente all'utente di specificare manualmente un'espressione booleana per una meta-variabile. Questa tactic, diversamente dalle altre, ha tipo $string \rightarrow Hoare.form \rightarrow tactic$, ovvero prende come argomenti il nome della meta-variabile ed una proposizione ed effettua la normalizzazione.

\section{Guida pratica all'utilizzo}
In questa sezione si descrive prima l'interfaccia del Controller e successivamente si da un esempio pratico di utilizzo.

\begin{itemize}
	\item \textbf{goal}: prende in input una stringa contenente una tripla di Hoare ed inizializza lo stato.
	\item \textbf{by}: prende in input una tactic e l'indice della formula a cui si intende applicarla ed aggiorna lo stato con i nuovi sub-goal generati. Si osservi che questa funzione accetta tutte le tactic definite in Rule ad eccezione di tacMeta per la quale bisogner\`a invece usare il comando meta.
	\item \textbf{meta}: prende in input il nome di una meta-variabile ed una proposizione ed invoca tacMeta.
	\item \textbf{pr}: stampa lo stato corrente.
    \item \textbf{undo}: annulla l'ultima modifica apportata ripristinando lo stato  precedente.
    \item \textbf{getState}: restituisce lo stato corrente. 
\end{itemize}
Come esempio di utilizzo si deriva la seguente tripla di Hoare:
\begin{equation*}
	\{x=1\} skip; \ if(x < 0) \ then\  x:=x+1 \ else \ x:=x+2 \ end \{x = 2\}
\end{equation*} 
Il primo passo consiste nel posizionarsi con il terminale nella directory del progetto ed avviare il REPL di ML:
\begin{center}
\begin{BVerbatim}
Standard ML of New Jersey v110.78 [built: Thu Jul 23 11:21:58 2015]
- 
\end{BVerbatim}
\end{center}
Si caricano i file sorgenti dell'applicazione:
\\
\\
\begin{BVerbatim}
- use "files.sml";
-
\end{BVerbatim}
\\
\\
Si apre la structure Controller:
\\
\\
\begin{BVerbatim}
- open Controller;
opening Controller
  val pr : unit -> unit
  val getState : unit -> Rule.state
  val goal : string -> unit
  val by : Rule.tactic -> unit
  val meta : string -> string -> unit
  val undo : unit -> unit
-
\end{BVerbatim}
\\
\\
Si specifica la formula da dimostrare invocando il comando \texttt{goal}. Ad ogni passo della dimostrazione viene stampato un elenco numerato delle formule presenti nello stato corrente. Ovviamente, in questo caso, l'elenco conterr\`a soltanto la formula iniziale.
\\
\\
\begin{BVerbatim}
- goal "{x=0}skip;if(x<0)then x:=x+1 else x:=x+2 end{x=2}";
1. {x = 0}skip; if (x < 0) then x := x + 1 else x := x + 2 end{x = 2}
val it = () : unit
- 
\end{BVerbatim}
\\
\\
Usando il comando \texttt{by} si applica la tactic \texttt{tacComp} all'unica formula presente. Si osservi come questo passo, essendo \texttt{tacComp} una meta-tactic, comporti l'introduzione della meta-variabile $\_a$:
\\
\\
\begin{BVerbatim}
- by(Rule.tacComp 1);
1. {x = 0}skip{_a}
2. {_a}if (x < 0) then x := x + 1 else x := x + 2 end{x = 2}
val it = () : unit
- 
\end{BVerbatim}
\\
\\
Siccome nello stato sono ora presenti due formule occorre sceglierne una. Si applica, pertanto, la tactic \texttt{tacIf} alla formula 2:
\\
\\
\begin{BVerbatim}
- by(Rule.tacIf 2);
1. {x = 0}skip{_a}
2. {_a & x < 0}x := x + 1{x = 2}
3. {_a & x >= 0}x := x + 2{x = 2}
val it = () : unit
- 
\end{BVerbatim}
\\
\\
A questo punto si applica \texttt{tacStr} alla formula 3 e successivamente \texttt{tacAssign} alla formula 4:
\\
\\
\begin{BVerbatim}
- by(Rule.tacStr 3);
1. {x = 0}skip{_a}
2. {_a & x < 0}x := x + 1{x = 2}
3. _a & x >= 0 -> _b
4. {_b}x := x + 2{x = 2}
val it = () : unit
- by(Rule.tacAssign 4);
1. {x = 0}skip{_a}
2. {_a & x < 0}x := x + 1{x = 2}
3. _a & x >= 0 -> _b
4. {_b : x + 2 = 2}x := x + 2{x = 2}
val it = () : unit
- 
\end{BVerbatim}
\\
\\
Si osservi come, a seguito dell'applicazione di \texttt{tacAssign}, la meta-variabile $\_b$ sia stata rimpiazzata dal meta-valore $\_b : x + 2 = 2$. Si pu\`o dunque normalizzare la meta-variabile $\_b$ usando il comando \texttt{tacNorm}:
\\
\\
\begin{BVerbatim}
- by(Rule.tacNorm 4);
1. {x = 0}skip{_a}
2. {_a & x < 0}x := x + 1{x = 2}
3. _a & x >= 0 -> x + 2 = 2
4. {x + 2 = 2}x := x + 2{x = 2}
val it = () : unit
-
\end{BVerbatim}
\\
\\
Siccome la formula 4 \`e un assioma, pu\`o essere eliminato con \texttt{tacAxiom}:
\\
\\
\begin{BVerbatim}
- by(Rule.tacAxiom 4);
1. {x = 0}skip{_a}
2. {_a & x < 0}x := x + 1{x = 2}
3. _a & x >= 0 -> x + 2 = 2
val it = () : unit
-
\end{BVerbatim}
\\
\\
Si osservi che la formula 3 non \`e una tripla di Hoare ma una proposizione che, prima di essere eliminata con \texttt{tacAxiom}, deve essere ricondotta ad un assioma dell'aritmetica. A tal fine si usa il comando \texttt{meta} per sostituire la meta-variabile $\_a$ con un'opportuna espressione.
\\
\\
\begin{BVerbatim}
- meta "_a" "x = 0";
1. {x = 0}skip{x = 0}
2. {x = 0 & x < 0}x := x + 1{x = 2}
3. x = 0 & x >= 0 -> x + 2 = 2
val it = () : unit
\end{BVerbatim}
\\
\\
A partire dallo stato corrente, digitando in sequenza i comandi \texttt{by(Rule.tacStr 2)}, \texttt{by(Rule.tacAssign 3)} e \texttt{by(Rule.tacNorm 3)} si ottiene il seguente stato (si noti l'utilizzo della funzione \texttt{pr}):
\\
\\
\begin{BVerbatim}
- pr();
1. {x = 0}skip{x = 0}
2. x = 0 & x < 0 -> x + 1 = 2
3. {x + 1 = 2}x := x + 1{x = 2}
4. x = 0 & x >= 0 -> x + 2 = 2
val it = () : unit
- 
\end{BVerbatim}
\\
\\
Ovviamente le quattro formule ottenute sono tutte degli assiomi e, in quanto tali, possono essere facilmente eliminate con $tacAxiom$. Supponendo che la formula 1 sia l'ultima ad essere eliminata, la dimostrazione terminer\`a nel seguente modo:
\\
\\
\begin{BVerbatim}
- pr();
1. {x = 0}skip{x = 0}
val it = () : unit
- by(Rule.tacAxiom 1);
No subgoals left! Milner says: <<Good job bro!>>
val it = () : unit
- 
\end{BVerbatim}
\\
\\
\end{document}
